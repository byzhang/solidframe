Here are some design ideas about multiconnections


1) Why

2) The timeout

Do we need it on per channel basis?

There are lots of situations I can think of, that need per channel timeout.
Here's a situation:
Suppose we wait for user commands on a channel, write em on another channel, then expect the response on that second channel.
We definitely want a shorter timeout on the second connection. The user might issue a command after an hour, but he definetly doesnt want the response to came after an hour.

2) Some use case studies

Most of the use cases I can think of, that the design may make a difference in performance, are related to proxies or group conversations.

2.a) Use case: Proxy one-to-one

We read on one socket and write on another open socket. For simplicity we suppose that all connections are established.
	. mark all completed buffers as either filled or emptied
	. if the first buffer is empty, issue read 0
	. if the second buffer is empty, issue read 1
	. if read successfull, mark buffer as filled
	. if the first buffer is filled, issue write 1
	. if the second buffer is filled, issue write 0
	. if the write is successfull, mark it as emptied
=========================================================
ProxyConnection::execute(ulong _evs, TimeSpec &_rtout){
	if(signaled()){
		
	}
	switch(state){
		case ReadInput:
			switch(channelRecv(buf, bufcp, 0/*flags*/, 0/*input channel*/)){
				case BAD: return BAD;
				case OK:break;
				case NOK:
					channelTimeout(10000,0/*inputchannel*/);
					state = WriteOutput;
					return NOK;
			};
		case WriteOutput:
			switch(channelSend(buf, bufsz, 0, 1)){
				case BAD: return BAD;
				case OK: 
					state = ReadInput;
					return OK;
				case NOK:
					_rtout += 10000;//10 sec
					state = ReadInput;
					return NOK;
			}
	}
}

=========================================================


2.b) Use case: Chat group
We read from any socket and write on all others.
The connections can come and go.
We suppose that connections can come as commands containing a pointer to a channel, so we only treat the leaving connections. We have a queue of connections ready for read, one with read buffers, and one with free buffers.
1. 
2. 
3. 
=========================================================
GroupConnection::execute(ulong _evs, TimeSpec &_rtout){
	if(signaled()){
		
	}
	for(DoneInterator it(channelDoneBegin()); it != channelDoneEnd(); ++it){
		if(it->revents & INDONE){
			writebufferq.push(WriteBuffer(waitReadBuffer(it->channelid)));
		}
		if(it->revents & OUTDONE){
			WaitBuffer *pwb(waitWriteBufferPop(it->channelid));
			if(!(--pwb->usecount)){
				freebuffers.push(pwb);
			}
		}
		if(it->revents & (ERRDONE | TIMEOUT)){
			disconectq.push(it->channelid);
		}
	}
	while(readreadyq.size() && freebuffers.size()){
		switch(channelRecv(freebuffers.top()->data, freebuffers.top()->size, readreadyq.top())){
			case BAD:
				disconectq.push(readreadyq.front());
				freebuffers.push(freebuffers.top());
				break;
			case OK:
				writebufferq.push(WriteBuffer(freebuffers.top(), readreadyq.top()));
				break;
			case NOK:
				waitReadBuffer(freebuffers.top(), readreadyq.top());
				break;
		}
		readreadyq.pop();
		freebuffers.pop();
	}
	while(writebufferq.size()){
		for(uint i = 0; i < channelCount(); ++i){
			if(i != writebufferq.front().channelid){//send on all others
				switch(channelSend(writebufferq.front()->data, writebufferq.front()->size, 0, i)){
					case BAD:
						disconectq.push(i);
						break;
					case OK:
						break;
					case NOK:
						waitWriteBuffer(writebufferq.front(), i);
						channelTimeout(_rtout, 10000, i);//10 secs
						break;
				}
			}
		}
		if(!writebufferq.front()->usecount){//the buffer was sent on all connections instantly
			freebuffers.push(writebufferq.front());
		}
		writebufferq.pop();
	}
}
=========================================================


3.c) Use case: ...