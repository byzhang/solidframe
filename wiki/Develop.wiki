#summary Start developing using SolidGround
#labels developing

= Introduction =

I suppose you've managed to build the *SolidGround* test applications, which means that you have a working copy. You'll now learn to develop using *SolidGround*.

= Building a KDevelop project =

{{{
solidground $ ./build.sh kdevelop debug
}}}

In KDevelop, open the project from: `/path/to/solidground/build/kdevelop/SOLIDGROUND.kdevelop`.

That's all, eventually you can configure KDevelop to use Subversion for project, and use 4 spaces wide tabs for indentation.

In the following lines I will present the way to start writing a new *SolidGround* application then I'll present the proof of concept test application.

= Adding a new application =

*SolidGround* repository copy contains an empty folder called "application". There's where your application(s) should reside.

So you should do something like:

{{{
solidground/application $ svn co https://foobarsuite.googlecode.com/svn/trunk/ foobar
}}}

So you'll have a repository copy of your application within `"solidground/application/foobar"`. With no files and no folders. Lets add some (we suppose the foobar contains: a client, a server and some applications test):

	# first you'll need to create the folders:
		{{{
		application/foobar $ mkdir server && svn add server
		application/foobar $ mkdir client && svn add client
		application/foobar $ mkdir test && svn add test
		}}}
	# next you'll need the CMakeLists.txt file that will look in every foobar's subfolder:
		{{{
		application/foobar $ cat > CMakeLists.txt
		add_subdirectory (server)
		add_subdirectory (client)
		add_subdirectory (test)
		# CTRL+C
		application/foobar $ touch server/CMakeLists.txt
		application/foobar $ touch client/CMakeLists.txt
		application/foobar $ touch test/CMakeLists.txt
		}}}
	# then you'll need to add the source files to every foobar subfolder, along with the CMakeLists.txt files.
	# last you'll need to integrate "foobar" into *SolidGround*'s build system. This is done by running solidground/build.sh again:
		{{{
		solidground $ ./build.sh debug
		}}}
	
	It will create `application/CMakeLists.txt` which will integrate all subfolders within 'application' into *SolidGround* cmake build system. 

As you can see, you can have multiple *SolidGround* based projects within 'application'.

= The proof of concept test application =

The Proof Of Concept Test Application (POCTA: `solidground/test/foundation/`) is a multi service, server offering:
	* an ALPHA service resembling IMAP on syntax;
	* echo service for TCP and UDP;
	* a proxy service.

You've built it and tested it, now lets dig into the code, as shows how the *SolidGround* libraries should be used.

Lets look first at the main function (`solidground/test/foundation/main/src/test.cpp`).


= The main function of the test server =

{{{
int main(int argc, char* argv[]){
}}}

Ignore the sigpipe signal:

{{{
	signal(SIGPIPE, SIG_IGN);
}}}

Parse the input parameters using tclap:

{{{
	Params p;
	if(parseArguments(p, argc, argv)) return 0;
}}}

Initiate the thread support:

{{{
	Thread::init();
}}}

Initiate the debug log engine either to log to a socket or to a file

{{{
#ifdef UDEBUG
	{
	string dbgout;
	if(p.dbg_addr.size() && p.dbg_port.size()){
		Dbg::instance().init(
			p.dbg_addr.c_str(),
			p.dbg_port.c_str(),
			p.dbg_levels.c_str(),
			p.dbg_modules.c_str(),
			p.dbg_buffered,
			&dbgout
		);
	}else{
		Dbg::instance().init(
			*argv[0] == '.' ? argv[0] + 2 : argv[0],
			p.dbg_levels.c_str(),
			p.dbg_modules.c_str(),
			p.dbg_buffered,
			3,
			1024 * 10,
			&dbgout
		);
	}
	cout<<"Debug output: "<<dbgout<<endl;
	dbgout.clear();
	Dbg::instance().moduleBits(dbgout);
	cout<<"Debug levels: "<<dbgout<<endl;
	}
#endif
}}}

Initiate the audit log engine and connect the client with the manager through a pipe:

{{{
	pipe(pairfd);
	audit::LogManager lm;
	lm.start();
	lm.insertChannel(new DeviceIOStream(pairfd[0], pairfd[1]));
	lm.insertListener("localhost", "3333");
	Directory::create("log");
	lm.insertConnector(new audit::LogBasicConnector("log"));
	Log::instance().reinit(argv[0], 0, "ALL", new DeviceIOStream(pairfd[1],-1));
}}}

Instantiate a Manager, add a new echo service, a new listener and a new talker to it:

{{{
	{
		test::Manager	tm;
		if(true){// create and register the echo service
			test::Service* psrvc = test::echo::Service::create();
			tm.insertService("echo", psrvc);
			
			{//add a new listener
				int port = p.start_port + 111;
				AddrInfo ai("0.0.0.0", port, 0, AddrInfo::Inet4, AddrInfo::Stream);
				if(!ai.empty()){
					if(!tm.insertListener("echo", ai.begin())){
						cout<<"added listener to echo "<<port<<endl;
					}else{
						cout<<"failed adding listener for service echo port "<<port<<endl;
					}
				}else{
					cout<<"failed create address for port "<<port<<" listener not created"<<endl;
				}
			}
			{//add a new talker
				int port = p.start_port + 112;
				AddrInfo ai("0.0.0.0", port, 0, AddrInfo::Inet4, AddrInfo::Datagram);
				if(!ai.empty()){
					AddrInfoIterator it(ai.begin());
					if(!tm.insertTalker("echo", ai.begin())){
						cout<<"added talker to echo "<<port<<endl;
					}else{
						cout<<"failed creating udp listener station "<<port<<endl;
					}
				}else{
					cout<<"empty addr info - no listener talker"<<endl;
				}
			}
		}
		/*
			...
			Initiate other services and wait for userinput. When user chooses to quit do:
			tm.stop();
			lm.stop();
		*/
	}
}}}

At the end of main function, after the manager was destroyed we do:

{{{	
	Thread::waitAll();
}}}

= The test core library =

Note that the test::Manager is declared within a block, and the waitAll() is called outside that block, so that it is called after the manager object is destroyed.

While at design level the central concept of the framework is the Pseudo-Active-Object class, at implementation level the central concept is the Manager object which provides the main way to interact with objects and services. As you can see in the above code the manager is a test::Manager which is also a foundation::Manager. Lets have a look at test::Manager (`test/foundation/core/src/manager.cpp`).

The test::Manager is the bottom container as it holds: the file manager, the active pools and the services. Most of the classes of the objects held by the manager are abstract and a local implementation (which consists mostly of simple lines of code) must be given. So we have to implement: a FileManager, an ipc::Service, a CommandExecuter (a PAO which all it does is to execute incoming Commands). Also the concrete active pools must be defined. Next the foundation::Manager is extended to allow insertion of services and different types of objects like connections, talkers, listeners etc. 

So, using the manager, one can add new connections (connections that will connect to a server), new listeners 
and/or new talkers (asynchronous UDP communication stubs) to a service.

The manager mixes all these and allows restrictive access to services and objects. A very important method not to be forgotten is:

{{{
static Manager& the(){return static_cast<Manager&>(foundation::Manager::the());}
}}}

This method is necessary because all concrete objects defined within "test" to access this test::Manager (and not the foundation::Manager, which is eventually accessed internally at the foundation level) 

Here is the code for pool definition:

{{{
typedef foundation::SelectPool<cs::ObjectSelector>					ObjSelPoolTp;
typedef foundation::SelectPool<cs::aio::Selector>					AioSelectorPoolTp;
}}}

and for creation and initialization:

{{{
Manager::Data::Data(Manager &_rm)
{
	pobjectpool[0] = NULL;
	pobjectpool[1] = NULL;
	
	paiopool[0] = NULL;
	paiopool[1] = NULL;
	
	TypeMapper::registerMap<IdTypeMap>(new IdTypeMap);
	TypeMapper::registerSerializer<BinSerializer>();
	idbg("");
	if(true){
		pobjectpool[0] = new ObjSelPoolTp(	_rm, 
												10,		//max thread cnt
												1024 * 4//max objects per selector
												);		//at most 10 * 4 * 1024 connections
		pobjectpool[0]->start(1);//start with one worker
	}
	idbg("");
	if(true){
		paiopool[0] = new AioSelectorPoolTp(_rm,
										10,			//max thread cnt
										2048		//max aio objects per selector/thread
										);			//at most 10 * 4 * 1024 connections
		paiopool[0]->start(1);//start with one worker
		
		paiopool[1] = new AioSelectorPoolTp(_rm,
										10,			//max thread cnt
										2048		//max aio objects per selector/thread
										);			//at most 10 * 4 * 1024 connections
		paiopool[1]->start(1);//start with one worker
	}
	idbg("");
}
}}}

Next we'll stop on the test::Service (`test/foundation/core/src/service.cpp`). The service is also a PAO which all it does is to wait for kill signal.

{{{
int Service::execute(ulong _sig, TimeSpec &_rtout){
	idbg("serviceexec sig = "<<_sig);
	if(signaled()){
		ulong sm;
		{
			Mutex::Locker	lock(*mut);
			sm = grabSignalMask(1);
		}
		if(sm & cs::S_KILL){
			idbg("killing service "<<this->id());
			this->stop(test::Manager::the(), true);
			test::Manager::the().removeService(this);
			return BAD;
		}
	}
	return NOK;
}
}}}


The test::Service is not a final service, it extends the foundation::Service but this is not final. The final services are defined in their corresponding library (e.g. test::alpha::Service `test/foundation/alpha/alphaservice.hpp`).

What is final and it is implemented in `test/foundation/core` is the listener, which is a PAO creating connections:

{{{
int Listener::execute(ulong, TimeSpec&){
	idbg("here");
	Manager &rm = Manager::the();
	Service	&rsrvc = rm.service(*this);
	cassert(this->socketOk());
	if(signaled()){
		{
		Mutex::Locker	lock(rm.mutex(*this));
		ulong sm = this->grabSignalMask();
		if(sm & foundation::S_KILL) return BAD;
		}
	}
	uint cnt(10);
	while(cnt--){
		if(state() == 0){
			switch(this->socketAccept(sd)){
				case BAD: return BAD;
				case OK:break;
				case NOK:
					state(1);
					return NOK;
			}
		}
		state(0);
		cassert(sd.ok());
		//TODO: one may do some filtering on sd based on sd.remoteAddress()
		if(pctx.get()){
			rsrvc.insertConnection(rm, sd, pctx.get(), true);
		}else{
			rsrvc.insertConnection(rm, sd);
		}
	}
	return OK;
}
}}}

Up till now you've learned about the `test/foundation/core` library, which is the basis for the proof of concept multiservice server application. You've learn about the central object, the test::Manager, you've learned about the base services and the listeners. As you've learned from above, every service has it's own library and folder. Let's take a look at the alpha service which is the most important service/protocol exported by the proof of concept server.

= The alpha service =

As every library in *SolidGround*, the test_alpha library has it own folder. The only public interface of the library is in the `alphaservice.hpp` file, the rest of the code, being private is within `alpha/src`. In `test/foundation/alpha/alphaservice.hpp` is declared the test::alpha::Service, which is instantiated in the application's main function and registered into the manager.

A service, while registered cannot be unregistered. A service can be inactive or active but it cannot be deleted.
As you can see from the code, the alpha service is a test core service and implements that interface allowing additions of connections and listeners. The only recommended way to directly access a service (I've tried to enforce in the code) is from its PAOs within PAOs execute function. The idea is that the service life will allways exceed its PAOs. See the test::Listener::execute, above, for an example.

So into an alpha service one can insert connections and listeners. The listeners are test::Listener while the connections are test::alpha::Connection(s) private to alpha library.

As the code form the alpha service is pretty simple we shall not delve into it. The only thing I'd like to add is some words about the destructions of services.
On manager stop this is what is done:
	* all objects from all services are signaled to stop including the services (which are also PAOs);
	* the active pools start executing the PAOs which in their turn exit with destroy code. The only difference between service PAOs and other PAOs is that services are not deleted, they are deleted on foundation::Manager destructor.

This is a quite nice approach because as you'll see, the shutdown time is very short even if lots of connections/ (and/or other objects are created).

Next we shall have a look at alpha::Connection (`src/alphaconnection.hpp` and `src/alphaconnection.cpp`).

Because alpha service features a quite complicated text protocol (resembling IMAP), the alpha::Connection features an extended protocol::Reader and protocol::Writer to simplify the asynchronous send, receive/parse operations. The connection also receives different commands. I believe the most complicated function from alpha is the alpha::Connection::execute which implements a rather not so simple state machine:

{{{
int Connection::execute(ulong _sig, TimeSpec &_tout){
	test::Manager &rm = test::Manager::the();
	fdt::requestuidptr->set(this->id(), rm.uid(*this));
	//_tout.add(2400);
	if(_sig & (fdt::TIMEOUT | fdt::ERRDONE)){
		if(state() == ConnectTout){
			state(Connect);
			return fdt::UNREGISTER;
		}else
			idbg("timeout occured - destroy connection");
			return BAD;
	}
	
	if(signaled()){//we've received a signal
		ulong sm(0);
		{
			Mutex::Locker	lock(rm.mutex(*this));
			sm = grabSignalMask(0);//grab all bits of the signal mask
			if(sm & fdt::S_KILL) return BAD;
			if(sm & fdt::S_CMD){//we have commands
				grabCommands();//grab them
			}
		}
		if(sm & fdt::S_CMD){//we've grabed commands, execute them
			switch(execCommands(*this)){
				case BAD: 
					return BAD;
				case OK: //expected command received
					_sig |= fdt::OKDONE;
				case NOK://unexpected command received
					break;
			}
		}
		//now we determine if we return with NOK or we continue
		if(!_sig) return NOK;
	}
	if(socketEvents() & fdt::ERRDONE){
		return BAD;
	}
	
	int rc;
	switch(state()){
		case Init:
			if(this->socketIsSecure()){
				int rv = this->socketSecureAccept();
				state(Banner);
				return rv;
			}else{
				state(Banner);
			}
		case Banner:{
			test::Manager	&rm = test::Manager::the();
			uint32			myport(rm.ipc().basePort());
			ulong			objid(this->id());
			uint32			objuid(rm.uid(*this));
			char			host[SocketAddress::MaxSockHostSz];
			char			port[SocketAddress::MaxSockServSz];
			SocketAddress	addr;
			writer()<<"* Hello from alpha server ("<<myport<<" "<<(uint32)objid<<" "<<objuid<<") [";
			socketLocalAddress(addr);
			addr.name(
				host,
				SocketAddress::MaxSockHostSz,
				port,
				SocketAddress::MaxSockServSz,
				SocketAddress::NumericService
			);
			writer()<<host<<':'<<port<<" -> ";
			socketRemoteAddress(addr);
			addr.name(
				host,
				SocketAddress::MaxSockHostSz,
				port,
				SocketAddress::MaxSockServSz,
				SocketAddress::NumericService | SocketAddress::NumericHost
			);
			writer()<<host<<':'<<port<<"]"<<'\r'<<'\n';
			writer().push(&Writer::flushAll);
			state(Execute);
			}break;
		case ParsePrepare:
			idbg("PrepareReader");
			prepareReader();
		case Parse:
			//idbg("Parse");
			state(Parse);
			switch((rc = reader().run())){
				case OK: break;
				case NOK:
					if(hasPendingRequests()){
						socketTimeout(_tout, 3000);
					}else{
						_tout.add(2000);
					}
					state(ParseTout);
					return NOK;
				case BAD:
					return BAD;
				case YIELD:
					return OK;
			}
			if(reader().isError()){
				delete pcmd; pcmd = NULL;
				logger.inFlush();
				state(Execute);
				writer().push(Writer::putStatus);
				break;
			}
		case ExecutePrepare:
			logger.inFlush();
			idbg("PrepareExecute");
			pcmd->execute(*this);
			state(Execute);
		case Execute:
			//idbg("Execute");
			switch((rc = writer().run())){
				case NOK:
					if(hasPendingRequests()){
						socketTimeout(_tout, 3000);
						state(ExecuteIOTout);
					}else{
						_tout.add(2000);
						idbg("no pendin io - wait twenty seconds");
						state(ExecuteTout);
					}
					return NOK;
				case OK:
					if(state() != IdleExecute){
						delete pcmd; pcmd = NULL;
						state(ParsePrepare); rc = OK;
					}else{
						state(Parse); rc = OK;
					}
				case YIELD:
					return OK;
				default:
					idbg("rc = "<<rc);
					return rc;
			}
			break;
		case IdleExecute:
			//idbg("IdleExecute");
			if(socketEvents() & fdt::OUTDONE){
				state(Execute);
				return OK;
			}return NOK;
		case Connect:
			/*
			switch(channel().connect(*paddr)){
				case BAD: return BAD;
				case OK:  state(Init);break;
				case NOK: state(ConnectTout); return REGISTER;
			};*/
			break;
		case ConnectTout:
			state(Init);
			//delete(paddr); paddr = NULL;
			break;
		case ParseTout:
			if(socketEvents() & fdt::INDONE){
				state(Parse);
				return OK;
			}
			return NOK;
		case ExecuteIOTout:
			idbg("State: ExecuteTout");
			if(socketEvents() & fdt::OUTDONE){
				state(Execute);
				return OK;
			}
		case ExecuteTout:
			return NOK;
	}
	return OK;
}
}}}

The idea is: the connection uses a rather simple state machine to asynchronously read and parse the input data using an alpha::Reader, building alpha::Command objects, execute those commands which in their turn, instruct the alpha::Writer to asynchronously build the output/command response. All commands are implemented in src/alphacommands.cpp.

As you can see from alpha code, the connection not only deals with IO events but also with incoming commands (containing: filestreams from FileManager, data from remote hosts in case of remotelist or fetch commands). Notable is the way the connection deals with the incoming commands, the way it forwards the to the current alpha::Command object:

{{{
//receiving an istream
int Connection::receiveIStream(
	StreamPtr<IStream> &_ps,
	const FileUidTp &_fuid,
	const RequestUidTp &_requid,
	int			_which,
	const ObjectUidTp&_from,
	const foundation::ipc::ConnectorUid *_conid
){
	idbg("");
	if(_requid.first && _requid.first != reqid) return OK;//not an expected command/request
	idbg("");
	newRequestId();//prevent multiple responses with the same id
	if(pcmd){
		switch(pcmd->receiveIStream(_ps, _fuid, _which, _from, _conid)){//forward the stream to command
			case BAD:
				idbg("");
				break;
			case OK:
				idbg("");
				if(state() == ParseTout){
					state(Parse);
				}
				if(state() == ExecuteTout){
					state(Execute);
				}
				break;
			case NOK:
				idbg("");
				state(IdleExecute);
				break;
		}
	}
	return OK;
}
}}}


Notable commands are: test::alpha::RemoteList and test::alpha::Fetch - see their implementation in `solidground/test/foundation/alpha/src/alphacommands.cpp`.

Alpha protocol is a test protocol designed as a proof of concept (showing the way the *SolidGround* foundation libraries should be used). The implementation though, is both not perfect and incomplete. It serves as a testing platform for new features and for stress testing in combination with some clients (`test/client/alpha`*``).

= Closing =

This presentation is not complete, there is lot of code and I believe that sample code "speaks better". So don't hesitate browsing the sample code and the framework code.

I'm sure that from this presentation you haven't learned to program with *SolidGround*, but I hope you've at least started to understand some of the design and what it offers. I also hope you've liked the design enough to have a better in-depth look at the code and maybe, just maybe start your own project to use *SolidGround*.