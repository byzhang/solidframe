#summary A step by step tutorial for start using SolidGround.

= Introduction =

Below I will present the steps you'll need to do to write your own SolidGround based application. Although in the beginning I will present how to setup the working space within the solidground/applications directory the rest of the text will present the proof of concept server from test/clientserver.

= Preparing the environment =

SolidGround (SG) is a framework which is also designed as a workspace. This means that your application should integrate into the SG's build system. I don't know if this is a good idea, but I believe it allows someone to easily start writing SG based code.

First of all you'll need to get a copy of the SG repository. See [
http://code.google.com/p/solidground/wiki/Introduction] (How to build and test the proof of concept server) wiki-page for the steps you need to do to build the SG's test applications.

Supposing that you successfully built the test applications, let's set up your application.

SG's build.sh creates a folder called "application" within the SG's folder. There's where your application should reside.

So you should do something like:
{{{
solidground $ svn co https://foobarsuite.googlecode.com/svn/trunk/ application
}}}


So you'll have a repository copy of your application within solidground/application. With no files and no folders. Lets add some (we suppose the foobarsuite contains: a client, a server and some test applications):
 # first you'll need to create the folders:
{{{
application $ mkdir foobar_server && svn add foobar_server
application $ mkdir foobar_client && svn add foobar_client
application $ mkdir test && svn add test
}}}
 # next you'll need the file that will integrate the application within SG's build system.
{{{
application $ cat > CMakeLists.txt
add_subdirectory (foobar_server)
add_subdirectory (foobar_client)
add_subdirectory (test)

CTRL+C
application $ touch foobar_server/CMakeLists.txt
application $ touch foobar_client/CMakeLists.txt
application $ touch test/CMakeLists.txt
}}}
 # then you'll need to add the source files to every foobar folder, along with the CMakeLists.txt files.

Because "foobar" is a fictional application/suite, I cannot continue with the structure. All I can point out is that you can have a look at SG's "test" and especially "test/clientserver" folder to get an idea of how the structure should look like.

Below I will present the structure of the proof of concept SG's test application.

= ClientServer test =

The SG's test clientserver (test_cs) application is a quite complex multi service server, using and testing most of SG's features. The server has three services:
 * two services *echo* and *beta*, implementing echo and/or echo-like protocols over TCP and UDP.
 * an *alpha* service with a complex IMAP-like syntax, text protocol.

The test/clientserver directory structure is as follows:

{{{
clientserver/
   alpha/
   beta/
   core/
   echo/
   main/
}}}


Interesting are the *core* and *main*:

 * The *core* defines things that are used by the services. Here is implemented the server, a service which extends the cs::Service and will be inherited by all test_cs's services, a base talker which extends cs::udp::Talker, a base connection which extends cs::tcp::Connection, a tcp listener extending cs::tcp::Listener and a base object.
 * The *main* folder contains only one file src/test.cpp implementing the application's main function.

Next I'll present the most interesting libraries of the test_cs.

== The _core_ folder ==

The structure of the _core_ folder follows the SG's standard with the public interface files directly under _core_ and a core/src folder containing the private header and source files.

Within the core library is defined
 * the server class, used across the test_cs application
 * intermediate classes between SG's and those used by services.

The core library is actually an intermediate one between the SG framework and the top level libraries dedicated to services.

Here are the most important components of the core library:

=== The server ===

The test::Server inherits and extends cs::Server. Here's what it does:
 * create and keep the active sets (the thread pools) allowing job insertion (pushJob<T>);
 * allows insertion of new services given a pointer to a service and its name (insertService);
 * keep the services in a name to service map;
 * allows adding different objects to services (insertTalker, insertConnection, insertListener);
 * keeps server wide global objects (e.g. binMapper);
 * creates and keeps diferent managers like filemanager and commnadexecuter.

The insert methods are just proxies for test::Service methods.

The pools are simply defined like this:
{{{
	typedef clientserver::SelectPool<cs::ObjectSelector>			ObjSelPoolTp;
	typedef clientserver::SelectPool<cs::tcp::ConnectionSelector>	ConSelPoolTp;
	typedef clientserver::SelectPool<cs::tcp::ListenerSelector>		LisSelPoolTp;
	typedef clientserver::SelectPool<cs::udp::TalkerSelector>		TkrSelPoolTp;
}}}

Instantiating a pool is simple:
{{{
if(true){	
	pconnectionpool = new ConSelPoolTp(_rs,
					10,		//max thread cnt
					50		//max connections per selector
					);		//at most 10 * 4 * 1024 connections
	pconnectionpool->start(1);//start with one worker
}
}}}

And adding a job to a pool is also straight forward:
{{{
template <>
void Server::pushJob(cs::Object *_pj, int _pos){
	d.pobjectpool[_pos]->push(cs::ObjPtr<cs::Object>(_pj));
}
}}}

In order to instantiate a cs::FileManager, one need to define some virtual members for asynchronously sending streams or errors to requesting objects.

Because the test::Server also extends the cs::Server interface, it also has to redefine the Server::the() method to access the server object from any thread of the server.

{{{
static inline Server& Server::the(){
    return static_cast<Server&>(clientserver::Server::the());
}
}}}

=== The Service ===

The test::Service also inherits and extends the cs::Service one, but things are a little more simple here:
 * implement the execute method so that the service is an active object:
{{{
int Service::execute(ulong _sig, TimeSpec &_rtout){
	idbg("serviceexec");
	if(signaled()){
		ulong sm;
		{
			Mutex::Locker	lock(*mut);
			sm = grabSignalMask(1);
		}
		if(sm & cs::S_KILL){
			idbg("killing service "<<this->id());
			this->stop(test::Server::the(), true);
			test::Server::the().removeService(this);
			return BAD;
		}
	}
	return NOK;//just wait
}
}}}
 * define virtual insertion methods for different objects (insertTalker, insertConnection, insertListener) and give them dummy implementation.

=== The Listener ===

The test::Listener inherits the cs::tcp::Listener and implements execute(...) to allow Connection creation. It is used by all services accepting tcp connections. Here is the execute loop:
{{{

Listener::~Listener(){
	test::Server &rs = test::Server::the();
	rs.service(*this).removeListener(*this);
}

int Listener::execute(ulong, TimeSpec&){
	idbg("here");
	Server &rs = Server::the();
	Service	&rsrvc = rs.service(*this);
	if(signaled()){
		{
		Mutex::Locker	lock(rs.mutex(*this));
		ulong sm = this->grabSignalMask();
		if(sm & clientserver::S_KILL) return BAD;
		}
	}
	station().accept(chvec);
	for(ChannelVecTp::iterator it(chvec.begin()); it != chvec.end(); ++it){
		if(rsrvc.insertConnection(rs, *it)){
			delete *it;
		}
	}
	return OK;
}

}}}


=== The Object, Connection ===

These are only meant to extend their cs:: counterparts, and be inherited by the ones from the services. Basically all they do is to extend the interface with methods for receiving different object types (receiveIStream, receiveOStream, receiveIOStream, receiveString, receiveNumber, receiveError). They also gives those methods dummy implementations.

{{{
virtual int receiveIStream(
	StreamPtr<IStream> &,
	const FileUidTp	&,
	const RequestUidTp &_requid,
	int			_which = 0,
	const ObjectUidTp&_from = ObjectUidTp(),
	const clientserver::ipc::ConnectorUid *_conid = NULL
);
virtual int receiveString(
	const String &_str,
	const RequestUidTp &_requid,
	int			_which = 0,
	const ObjectUidTp&_from = ObjectUidTp(),
	const clientserver::ipc::ConnectorUid *_conid = NULL
);
}}}

== The _alpha_ folder ==

== The _main_ folder ==