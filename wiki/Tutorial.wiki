#summary A step by step tutorial for start using SolidGround.

= Introduction =

Below I will present the steps you'll need to do to write your own SolidGround based application. Although in the beginning I will present how to setup the working space within the solidground/applications directory the rest of the text will present the proof of concept server from test/clientserver.

= Preparing the environment =

SolidGround (SG) is a framework which is also designed as a workspace. This means that your application should integrate into the SG's build system. I don't know if this is a good idea, but I believe it allows someone to easily start writing SG based code.

First of all you'll need to get a copy of the SG repository. See [
http://code.google.com/p/solidground/wiki/Introduction] (How to build and test the proof of concept server) wiki-page for the steps you need to do to build the SG's test applications.

Supposing that you successfully built the test applications, let's set up your application.

SG's repository contains an empty folder called "application". There's where your application(s) should reside.

So you should do something like:
{{{
solidground/application $ svn co https://foobarsuite.googlecode.com/svn/trunk/ foobar
}}}


So you'll have a repository copy of your application within "solidground/application/foobar". With no files and no folders. Lets add some (we suppose the foobar contains: a client, a server and some test applications):
 # first you'll need to create the folders:
{{{
application/foobar $ mkdir server && svn add server
application/foobar $ mkdir client && svn add client
application/foobar $ mkdir test && svn add test
}}}
 # next you'll need the CMakeLists.txt file that will look in every foobar's subfolder:
{{{
application/foobar $ cat > CMakeLists.txt
add_subdirectory (server)
add_subdirectory (client)
add_subdirectory (test)

CTRL+C
application/foobar $ touch server/CMakeLists.txt
application/foobar $ touch client/CMakeLists.txt
application/foobar $ touch test/CMakeLists.txt
}}}
 # then you'll need to add the source files to every foobar subfolder, along with the CMakeLists.txt files.
 # last you'll need to integrate "foobar" into _solidground_'s build system. This is done by running solidground/build.sh again. It will create application/CMakeLists.txt which will integrate all subfolders within application into cmake build system.

As you can see, you can have multiple SG based projects within application.

NOTE:

 # I'm using KDevelop IDE (http://www.kdevelop.org/) for managing the SolidGround project. To do that too, you'll need to run the build script this way:

{{{
build.sh kdevelop nolog
}}}

(instead of _nolog_ you can use other target specifications - debug, release etc.)
Then open the KDevelop project residing within: solidground/build/kdevelop/SOLIDGROUND.kdevelop

Because "foobar" is a fictional application/suite, I cannot continue with the structure. All I can point out is that you can have a look at SG's "test" and especially "test/clientserver" folder to get an idea of how the structure should look like.

Below I will present the structure of the proof of concept SG's test application.

= ClientServer test =

The SG's test clientserver (test_cs) application is a quite complex multi service server, using and testing most of SG's features. The server has three services:
 * two services *echo* and *beta*, implementing echo and/or echo-like protocols over TCP and UDP.
 * an *alpha* service with a complex IMAP-like syntax, text protocol.

The test/clientserver directory structure is as follows:

{{{
clientserver/
   alpha/
   beta/
   core/
   echo/
   main/
}}}


Interesting are the *core* and *main*:

 * The *core* defines things that are used by the services. Here is implemented the server, a service which extends the cs::Service and will be inherited by all test_cs's services, a base talker which extends cs::udp::Talker, a base connection which extends cs::tcp::Connection, a tcp listener extending cs::tcp::Listener and a base object.
 * The *main* folder contains only one file src/test.cpp implementing the application's main function.

Next I'll present the most interesting libraries of the test_cs.

== The _core_ folder ==

The structure of the _core_ folder follows the SG's standard with the public interface files directly under _core_ and a core/src folder containing the private header and source files.

Within the core library is defined
 * the server class, used across the test_cs application
 * intermediate classes between SG's and those used by services.

The core library is actually an intermediate one between the SG framework and the top level libraries dedicated to services.

Here are the most important components of the core library:

=== The server ===

The test::Server inherits and extends cs::Server. Here's what it does:
 * create and keep the active sets (the thread pools) allowing job insertion (pushJob<T>);
 * allows insertion of new services given a pointer to a service and its name (insertService);
 * keep the services in a name to service map;
 * allows adding different objects to services (insertTalker, insertConnection, insertListener);
 * keeps server wide global objects (e.g. binMapper);
 * creates and keeps diferent managers like filemanager and commnadexecuter.

The insert methods are just proxies for test::Service methods.

The pools are simply defined like this:
{{{
	typedef clientserver::SelectPool<cs::ObjectSelector>			ObjSelPoolTp;
	typedef clientserver::SelectPool<cs::tcp::ConnectionSelector>		ConSelPoolTp;
	typedef clientserver::SelectPool<cs::tcp::ListenerSelector>		LisSelPoolTp;
	typedef clientserver::SelectPool<cs::udp::TalkerSelector>		TkrSelPoolTp;
}}}

Instantiating a pool is simple:
{{{
if(true){	
	pconnectionpool = new ConSelPoolTp(_rs,
					10,		//max thread cnt
					50		//max connections per selector
					);		//at most 10 * 4 * 1024 connections
	pconnectionpool->start(1);//start with one worker
}
}}}

And adding a job to a pool is also straight forward:
{{{
template <>
void Server::pushJob(cs::Object *_pj, int _pos){
	d.pobjectpool[_pos]->push(cs::ObjPtr<cs::Object>(_pj));
}
}}}

In order to instantiate a cs::FileManager, one need to define some virtual members for asynchronously sending streams or errors to requesting objects.

Because the test::Server also extends the cs::Server interface, it also has to redefine the Server::the() method to access the server object from any thread of the server.

{{{
static inline Server& Server::the(){
    return static_cast<Server&>(clientserver::Server::the());
}
}}}

=== The Service ===

The test::Service also inherits and extends the cs::Service one, but things are a little more simple here:
 * implement the execute method so that the service is an active object:
{{{
int Service::execute(ulong _sig, TimeSpec &_rtout){
	idbg("serviceexec");
	if(signaled()){
		ulong sm;
		{
			Mutex::Locker	lock(*mut);
			sm = grabSignalMask(1);
		}
		if(sm & cs::S_KILL){
			idbg("killing service "<<this->id());
			this->stop(test::Server::the(), true);
			test::Server::the().removeService(this);
			return BAD;
		}
	}
	return NOK;//just wait
}
}}}
 * define virtual insertion methods for different objects (insertTalker, insertConnection, insertListener) and give them dummy implementation.

=== The Listener ===

The test::Listener inherits the cs::tcp::Listener and implements execute(...) to allow Connection creation. It is used by all services accepting tcp connections. Here is the execute loop:
{{{

Listener::~Listener(){
	test::Server &rs = test::Server::the();
	rs.service(*this).removeListener(*this);
}

int Listener::execute(ulong, TimeSpec&){
	idbg("here");
	Server &rs = Server::the();
	Service	&rsrvc = rs.service(*this);
	if(signaled()){
		{
		Mutex::Locker	lock(rs.mutex(*this));
		ulong sm = this->grabSignalMask();
		if(sm & clientserver::S_KILL) return BAD;
		}
	}
	station().accept(chvec);
	for(ChannelVecTp::iterator it(chvec.begin()); it != chvec.end(); ++it){
		if(rsrvc.insertConnection(rs, *it)){
			delete *it;
		}
	}
	return OK;
}

}}}


=== The Object, Connection ===

These are only meant to extend their cs:: counterparts, and be inherited by the ones from the services. Basically all they do is to extend the interface with methods for receiving different object types (receiveIStream, receiveOStream, receiveIOStream, receiveString, receiveNumber, receiveError). They also gives those methods dummy implementations.

{{{
virtual int receiveIStream(
	StreamPtr<IStream> &,
	const FileUidTp	&,
	const RequestUidTp &_requid,
	int			_which = 0,
	const ObjectUidTp&_from = ObjectUidTp(),
	const clientserver::ipc::ConnectorUid *_conid = NULL
);
virtual int receiveString(
	const String &_str,
	const RequestUidTp &_requid,
	int			_which = 0,
	const ObjectUidTp&_from = ObjectUidTp(),
	const clientserver::ipc::ConnectorUid *_conid = NULL
);
}}}

== The _alpha_ folder ==

Contains the implementation of alpha service/protocol. The only public header file is the _alphaservice.h_, the rest of the source files being in the _src_ sub folder.

Here are the basic steps needed to write the alpha service (and most tcp text protocols):
 # Inherit test::Service and implement needed insert methods (alpha/src/alphaservice.cpp):
{{{
int Service::insertConnection(
	test::Server &_rs,
	clientserver::tcp::Channel *_pch
){
	Connection *pcon = new Connection(_pch, 0);
	if(this->insert(*pcon, _rs.serviceId(*this))){
		delete pcon;
		return BAD;
	}	
	_rs.pushJob((cs::tcp::Connection*)pcon);
	return OK;
}

//and remove methods:

int Service::removeConnection(Connection &_rcon){
	this->remove(_rcon);
	return OK;
}
}}}
 # Implement alpha::Connection (alpha/src/alphaconnection.h/cpp) which inherits and extends the test::Connection. It will implement the protocol state machine in the execute(...) method and the receiveSomething methods. Basically the state machine will mean:
  * wait for a new data from client;
  * parse the data until having the current command name;
  * create a concrete alpha::Command object based on the name, and let the command initiate the alpha::Reader to parse the command parameters;
  * after the command was successfully parsed, execute it to initiate the alpha::Responder to asynchronously build the reponse;
  * when done writing start allover again.
  And the receiveSomething methods will just be proxies methods to forward the data to the equivalent alpha::Command methods, ensuring that the received data is the one expected:
{{{
int Connection::receiveIStream(
	StreamPtr<IStream> &_ps,
	const FileUidTp &_fuid,
	const RequestUidTp &_requid,
	int			_which,
	const ObjectUidTp&_from,
	const clientserver::ipc::ConnectorUid *_conid
){
	if(_requid.first && _requid.first != reqid) return OK;
	newRequestId();//prevent multiple responses with the same id
	if(pcmd){
		switch(pcmd->receiveIStream(_ps, _fuid, _which, _from, _conid)){
			case BAD:
				break;
			case OK:
				if(state() == ParseTout){
					state(Parse);
				}
				break;
			case NOK:
				state(IdleExecute);
				break;
		}
	}
	return OK;
}
}}}
 # Define a base class for all alpha protocol commands (alpha/src/alphacommand.h).
 # Define an alpha::Reader inheriting and extending the algorithm::protocol::Reader to better fit the alpha syntax (alpha/src/alphareader.h/cpp).
 # Define an alpha::Writer inheriting and extending the algorithm::protocol::Writer to better fit the alpha syntax (alpha/src/alphawriter.h/cpp). 
 # Define the alpha commands (alpha/src/alphacommands.h/cpp)

Here's the definitions of the alpha list command methods:

{{{
void List::initReader(Reader &_rr){
	_rr.push(&Reader::fetchAString, protocol::Parameter(&strpth));
	_rr.push(&Reader::checkChar, protocol::Parameter(' '));
}
int List::execute(Connection &_rc){
	idbg("path: "<<strpth);
	fs::path pth(strpth.c_str(), fs::native);
	protocol::Parameter &rp = _rc.writer().push(&Writer::putStatus);
	rp = protocol::Parameter(StrDef(" OK Done LIST@"));
	if(!is_directory(pth)){
		rp = protocol::Parameter(StrDef(" NO LIST: Not a directory@"));
		return OK;
	}
	it = fs::directory_iterator(pth);
	_rc.writer().push(&Writer::reinit<List>, protocol::Parameter(this, Step));
	if(it != end){
		_rc.writer().push(&Writer::putCrlf);
		_rc.writer().push(&Writer::putAString, protocol::Parameter((void*)it->string().data(), it->string().size()));
		if(is_directory(*it)){
			_rc.writer()<<"* DIR ";
		}else{
			_rc.writer()<<"* FILE "<<(uint32)file_size(*it)<<' ';
		}
	}
	return OK;
}

int List::reinitWriter(Writer &_rw, protocol::Parameter &_rp){
	++it;
	if(it != end){
		_rw.push(&Writer::putCrlf);
		_rw.push(&Writer::putAString, protocol::Parameter((void*)it->string().data(), it->string().size()));
		if(is_directory(*it)){
			_rw<<"* DIR ";
		}else{
			_rw<<"* FILE "<<(uint32)file_size(*it)<<' ';
		}
		return Writer::Continue;
	}
	return Writer::Ok;
}

}}}

== The _main_ folder ==
The main function will create a new server, add new services to it and talkers / listeners / connections to those services. It will also implement a very simple CLI.

Here's how the alpha service is created:
{{{
test::Server	ts;
if(true){
	test::Service* psrvc = test::alpha::Service::create(ts);
	ts.insertService("alpha", psrvc);
	int port = startport + 114;
	AddrInfo ai("0.0.0.0", port, 0, AddrInfo::Inet4, AddrInfo::Stream);
	if(!ai.empty() && !ts.insertListener("alpha", ai.begin())){
		cout<<"added listener for service alpha "<<port<<endl;
	}else{
		cout<<"failed adding listener for service alpha port "<<port<<endl;
	}	
}
}}}