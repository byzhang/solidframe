#summary Presenting some of the new additions and changes.

= Introduction =

SolidGround has received lately some very nice additions and improvements:
  # an audit/logging module;
  # keep alive support for ipc
  # redesign the asynchronous socket communication. 
  
In the following lines I shall present each of them.

= Audit Logging Module =

The logging module has two sides: 
  * the client side, which is used for specifying log lines;
  * and the server side which is used for filtering and sending log lines to appropriate destinations.

The log lines have some properties:
  * a log level:  info, error, warn, debug, io;
  * The module which sent the log line, which is configurable. Here are some predefined: any, aio, aio_tcp, aio_udp, filemanager, ipc etc.
  * An id (uint32) which is particular to every module.
  * the source file where is the log line.
  * the source file line where is the log line.
  * the name of the current function.

All these properties can be filtered and someone can either drop the log line, or send it to an appropriate destination (e.g. one can extend the logging engine to send log lines to different log files for every module).
Here is a snapshot from the test/audit/log/server.cpp:
{{{
#include <iostream>
#include "audit/log/logmanager.hpp"
#include "audit/log/logconnectors.hpp"
#include "audit/log.hpp"
#include "utility/iostream.hpp"
#include "system/thread.hpp"
#include "system/directory.hpp"
#include "system/debug.hpp"

using namespace std;

struct DeviceIOStream: IOStream{
	DeviceIOStream(int _d, int _pd):d(_d), pd(_pd){}
	void close(){
		int tmp = d;
		d = -1;
		if(pd > 0){
			::close(tmp);
			::close(pd);
		}
	}
	/*virtual*/ int read(char *_pb, uint32 _bl, uint32 _flags = 0){
		int rv = ::read(d, _pb, _bl);
		return rv;
	}
	/*virtual*/ int write(const char *_pb, uint32 _bl, uint32 _flags = 0){
		return ::write(d, _pb, _bl);
	}
	int64 seek(int64, SeekRef){
		return -1;
	}
	int d;
	int pd;
};

int pairfd[2];

int main(int _argc, char *argv[]){
	pipe(pairfd);
	string ds = argv[0] + 2;
	Dbg::instance().init(ds, ds.c_str(), Dbg::AllLevels, "any");
	audit::LogManager lm;
	lm.start();
	lm.insertChannel(new DeviceIOStream(pairfd[0], pairfd[1]));
	lm.insertListener("localhost", "3333");
	Directory::create("log");
	lm.insertConnector(new audit::LogBasicConnector("log"));
	Log::instance().reinit(argv[0], Log::AllLevels, "ALL", new DeviceIOStream(pairfd[1],-1));
	
	string s;
	while(true){
		cin>>s;
		if(s.size() == 1 && tolower(s[0]) == 'q') break;
		ilog(Log::any, s.size(), "new text : "<<s);
	}
	lm.stop(true);
	Thread::waitAll();
}
}}}
