#summary Presenting some of the new additions and changes.

= Introduction =

SolidGround has received lately some very nice additions and improvements:
  # an audit/logging module;
  # keep alive support for ipc
  # redesign the asynchronous socket communication. 
  
In the following lines I shall present each of them.

= Audit Logging Module =

The logging module has two sides: 
  * the client side, which is used for specifying log lines;
  * and the server side which is used for filtering and sending log lines to appropriate destinations.

The log lines have some properties:
  * a log level:  info, error, warn, debug, io;
  * The module which sent the log line, which is configurable. Here are some predefined: any, aio, aio_tcp, aio_udp, filemanager, ipc etc.
  * An id (uint32) which is particular to every module.
  * the source file where is the log line.
  * the source file line where is the log line.
  * the name of the current function.

All these properties can be filtered and someone can either drop the log line, or send it to an appropriate destination (e.g. one can extend the logging engine to send log lines to different log files for every module).
Here is a snapshot from the test/audit/log/server.cpp:
{{{
#include <iostream>
#include "audit/log/logmanager.hpp"
#include "audit/log/logconnectors.hpp"
#include "audit/log.hpp"
#include "utility/iostream.hpp"
#include "system/thread.hpp"
#include "system/directory.hpp"
#include "system/debug.hpp"

using namespace std;

struct DeviceIOStream: IOStream{
	DeviceIOStream(int _d, int _pd):d(_d), pd(_pd){}
	void close(){
		int tmp = d;
		d = -1;
		if(pd > 0){
			::close(tmp);
			::close(pd);
		}
	}
	/*virtual*/ int read(char *_pb, uint32 _bl, uint32 _flags = 0){
		int rv = ::read(d, _pb, _bl);
		return rv;
	}
	/*virtual*/ int write(const char *_pb, uint32 _bl, uint32 _flags = 0){
		return ::write(d, _pb, _bl);
	}
	int64 seek(int64, SeekRef){
		return -1;
	}
	int d;
	int pd;
};

int pairfd[2];

int main(int _argc, char *argv[]){
	pipe(pairfd);
	string ds = argv[0] + 2;
	Dbg::instance().init(ds, ds.c_str(), Dbg::AllLevels, "any");
	audit::LogManager lm;
	lm.start();
	lm.insertChannel(new DeviceIOStream(pairfd[0], pairfd[1]));
	lm.insertListener("localhost", "3333");
	Directory::create("log");
	lm.insertConnector(new audit::LogBasicConnector("log"));
	Log::instance().reinit(argv[0], Log::AllLevels, "ALL", new DeviceIOStream(pairfd[1],-1));
	
	string s;
	while(true){
		cin>>s;
		if(s.size() == 1 && tolower(s[0]) == 'q') break;
		ilog(Log::any, s.size(), "new text : "<<s);
	}
	lm.stop(true);
	Thread::waitAll();
}
}}}

As you can see it uses a pipe to communicate from client to server (one can easily modify it to use socketpair), it initiate the server module and then logs the user inserted strings on info level.
The server can also listen for tcp connections on port 3333.
One can also insert multiple channels and/or listeners.

= The keep alive support for ipc =

The ipc service can now the configured to use keep alive in order to detect peer side disconnection. So if configured, the ipc engine can send keep alive buffers from time to time when there are commands waiting for responses from the peer side.
Some times is quite helpful when you send a command for which you wait for a response. For how log should you wait for the response?
Using ipc keep alive, the command sent to a peer, if it is waiting for a response it is not immediately deleted, it is kept, until either the response has come, or a disconnect is detected, in which case it (the command) can be used to inform the sender that the response will never come.
Notable is that no keep alive data is transmitted if no response is awaited.

= Redesign the asynchronous socket communication =

The previous aio design had one big problem: it had selector pools for every type of socket: one pool for tcp channel, one for tcp listener and one for udp.
So here comes the new design which improves the situation: one aio selector pool.
So with an aio::Selector with capacity large enough, one can do all socket io in one single thread.
Another problem with the previous design is that it didn't allow for easy and powerful implementations for proxies or multi connections (connection with multiple sockets).

With the new design, one can have connections using multiple sockets: e.g. two for proxies.

Here's another situation: group chat.
One can have a MultiListener, which listens on one socket for new connections, then asynchronously wait for user authentication and chat-room request, then send the connection stub to the appropriate chat-room's MultiConnection object.


 
